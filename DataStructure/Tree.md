# Tree

Node와 Edge로 이루어진 자료구조

트리는 값을 가진 `노드(Node)`와 이 노드들을 연결해주는 `간선(Edge)`으로 이루어져있다.

그림 상 데이터 1을 가진 노드가 `루트(Root) 노드`다.

모든 노드들은 0개 이상의 자식(Child) 노드를 갖고 있으며 보통 부모-자식 관계로 부른다.

## 특징

- 트리에는 사이클이 존재할 수 없다. (만약 사이클이 만들어진다면, 그것은 트리가 아니고 그래프다)
- 모든 노드는 자료형으로 표현이 가능하다.
- 루트에서 한 노드로 가는 경로는 유일한 경로 뿐이다.
- 노드의 개수가 N개면, 간선은 N-1개를 가진다.

## 트리 순회 방식

![image.png](attachment:4b0f9a05-932f-4444-bbcc-2e4a71203231:image.png)

1. 전위 순회(pre-order)
    
    각 부모 노드를 순차적으로 먼저 방문하는 방식이다.
    
    (부모 → 왼쪽 자식 → 오른쪽 자식)
    
    > 1 → 2 → 4 → 8 → 9 → 5 → 10 → 11 → 3 → 6 → 13 → 7 → 14
    > 
2. 중위 순회(in-order)
    
    왼쪽 하위 트리를 방문 후 부모 노드를 방문하는 방식이다.
    
    (왼쪽 자식 → 부모 → 오른쪽 자식)
    
    > 8 → 4 → 9 → 2 → 10 → 5 → 11 → 1 → 6 → 13 → 3 →14 → 7
    > 
3. 후위 순회(post-order)
    
    왼쪽 하위 트리부터 하위를 모두 방문 후 부모 노드를 방문하는 방식이다.
    
    (왼쪽 자식 → 오른쪽 자식 → 부모)
    
    > 8 → 9 → 4 → 10 → 11 → 5 → 2 → 13 → 6 → 14 → 7 → 3 → 1
    > 
4. 레벨 순회(level-order)
    
    부모 노드부터 계층 별로 방문하는 방식이다.
    
    > 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10 → 11 → 13 → 14
    > 

## 트리를 사용하는 이유

### **1. 탐색 속도 향상 (빠른 검색)** 🚀

트리는 데이터 탐색 속도를 높이기 위해 사용돼.

예를 들어, 배열이나 리스트에서 **탐색(검색)** 할 때는 **O(n)** 시간이 걸리지만,

- *이진 탐색 트리(Binary Search Tree, BST)**를 사용하면 **O(log n)** 으로 줄일 수 있어.

📌 **예시**:

- **이진 탐색 트리 (BST)**
- **B-Tree (데이터베이스 인덱스 구조)**
- **Trie (문자열 검색 최적화, 사전 검색)**

👉 **예제 비교**

> 배열에서 50을 찾을 때 → O(n)
> 
> 
> 트리에서 `50`을 찾을 때 → O(log n)
> 

```
markdown
복사편집
      50
     /  \
   30    70
  /  \   /  \
10   40 60  80

```

**➡ `50` 찾기: 단 1번 탐색으로 끝!**

### **2. 효율적인 데이터 저장 및 구조화** 📂

트리는 데이터를 **계층적으로 정리**하는 데 적합해.

즉, **부모 - 자식 관계**가 있는 데이터는 트리 구조가 가장 적합해.

📌 **예시**:

- **파일 시스템 (디렉터리 구조)**
- **HTML 문서 구조 (DOM)**
- **게임 오브젝트 계층 구조 (게임 개발)**
- **회사 조직도**

👉 **파일 시스템 예제**

```
markdown
복사편집
Root
 ├── Users
 │   ├── Alice
 │   ├── Bob
 │   └── Charlie
 ├── Program Files
 │   ├── Chrome
 │   ├── Photoshop
 │   └── VSCode
 └── Windows
     ├── System32
     ├── Logs
     └── Temp

```

➡ **파일이 계층적으로 저장되어 있어서 검색, 이동, 정리가 편리함!**

### **3. 유연한 확장성과 동적 변경 가능** 🔄

배열은 크기가 고정되어 있고, **데이터 추가/삭제가 어렵지만**

트리는 **동적으로 크기를 조절**할 수 있어서 확장성이 뛰어나.

📌 **예시**:

- **데이터베이스 인덱스 (B-Tree, B+Tree)**
- **게임 캐릭터 상태 트리 (AI, 의사결정 트리)**
- **네트워크 라우팅 트리**

👉 **데이터베이스에서 B-Tree 사용 예제**

```
css
복사편집
       [ 50 ]
      /     \
  [10, 20]  [60, 70, 80]

```

➡ **데이터가 많아져도 균형을 유지하면서 빠르게 검색 가능!**

### **4. 최적화된 경로 탐색** 🛤️

트리는 **경로(Path)를 찾는 데 최적화된 구조**야.

그래서 **최단 경로 알고리즘** 같은 경우에도 트리를 활용해.

📌 **예시**:

- **네트워크 라우팅 (최단 경로 탐색)**
- **다익스트라 알고리즘 (Dijkstra's Algorithm)**
- *A 알고리즘 (게임 AI, 네비게이션 시스템)*

👉 **네트워크 라우팅 트리 예제**

```
mathematica
복사편집
       A
      / \
     B   C
    / \   \
   D   E   F

```

➡ **A에서 F까지 가는 최적의 경로를 쉽게 찾을 수 있음!**