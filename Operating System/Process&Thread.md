# Process & Thread

## 프로세스

- 각 프로세스는 독립된 메모리 공간을 사용하며, 프로세스 간 데이터 공유는 어려움
- 코드 예제 : `fork()` 를 사용한 멀티 프로세스
    
    ```c
    #include <iostream>
    #include <unistd.h>
    
    void printNumbers() {
        for (int i = 0; i < 5; i++) {
            std::cout << "Process ID: " << getpid() << ", Number: " << i << std::endl;
        }
    }
    
    int main() {
        pid_t pid1 = fork(); // 첫 번째 프로세스 생성
    
        if (pid1 == 0) {
            // 자식 프로세스 1
            printNumbers();
        } else {
            pid_t pid2 = fork(); // 두 번째 프로세스 생성
            if (pid2 == 0) {
                // 자식 프로세스 2
                printNumbers();
            } else {
                // 부모 프로세스
                std::cout << "Parent Process ID: " << getpid() << std::endl;
            }
        }
    
        return 0;
    }
    
    ```
    
    - 결과
    - ![image](https://github.com/user-attachments/assets/03bd7fb6-2ef5-4c18-a891-ada3ec6b0267)

    
    - `main` 함수 실행 → 최초의 부모 프로세스 (`5960`) 생성
    - fork() 함수가 여러 번 호출되면서 프로세스가 동시에 실행될 때, 각각의 프로세스가 어떤 순서로 CPU를 할당 받을지 운영체제 스케줄러가 결정한다
        - 따라서 출력 결과의 순서는 뒤죽박죽 섞일 수 있다
        - 즉, 두 자식 프로세스와 부모 프로세스가 동시에 또는 번갈아가며 실행되기 때문에, 순서가 일정하지 않다.
    - `pid1` 은 if (pid1 == 0) 안에서 printNumbers()만 수행하고 종료한다.
    - 따라서 `pid_t pid2 = fork();` 에서 부모 프로세스의 자식이 하나 만들어져서 실행하므로 2번의 `printNumbers()` 를 호출한다.
    - 구조
        
        ```c
        Parent Process (PID: 5960)
        ├── First Child Process (PID: 5961) → printNumbers() 실행
        └── Second Child Process (PID: 5962) → printNumbers() 실행
        ```
        

- 실행 중인 프로그램  
  ![image (1)](https://github.com/user-attachments/assets/cbd9266b-9a25-4ba4-9f62-95527cc37114)



- OS로부터 주소공간, 파일, 메모리 등을 할당받음
- 프로세스는 함수의 매개 변수, 복귀 주소, 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다.

### 프로세스 제어 블록(PCB) - Process Control Block
![image (2)](https://github.com/user-attachments/assets/69061f21-0bc2-4e7a-82a8-c50bd5f663a3)



- 특정 프로세스에 대한 중요한 정보를 저장하고 있는 `OS의 자료구조`
- OS는 프로세스를 관리하기 위해 `프로세스 생성` 과 동시에 `고유한 PCB`를 생성
- 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환(`context switch`)이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 하는데, 이때 `작업의 진행상황을 PCB에 저장`
- PCB에 저장되는 정보
    - 프로세스 식별자(Process ID, PID) : 프로세스 식별 번호
    - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
    - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
    - CPU 레지스터
    - CPU 스케줄링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
    - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
    - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
    - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정 번호 등

## PCB와 제어 스택의 주요 차이점

| **구분** | **PCB (Process Control Block)** | **제어 스택 (Control Stack)** |
| --- | --- | --- |
| **저장 위치** | 운영 체제의 커널 영역 | 사용자 프로세스의 메모리 영역 |
| **주요 목적** | 프로세스의 전반적인 상태와 관리 정보 저장 | 함수 호출 및 복귀 정보, 실행 흐름 관리 |
| **저장 정보** | 프로세스 ID, 상태, 메모리 정보, 입출력 정보 등 | 함수 복귀 주소, 로컬 변수, 매개변수 등 |
| **수명** | 프로세스가 생성될 때 생성되고 종료 시 삭제 | 함수 호출 시 생성, 함수 반환 시 삭제 |
| **사용 대상** | 운영 체제가 프로세스 전환 및 관리에 사용 | 프로세스 실행 중, 함수 호출 흐름 관리 |
| **상태 저장** | 프로세스 전환 시 CPU 레지스터, 메모리 상태 저장 | 인터럽트 발생 시 현재 작업 상태 저장 |

## 스레드(Thread)

- 스레드는 프로세스 내에서 실행되는 독립적인 작업 흐름을 말하며, 프로세스는 하나 이상의 스레드로 구성될 수 있다
- 특징
    - 같은 프로세스 내의 스레드는 메모리(힙 영역)를 공유하여 통신이 간단하지만, 동기화 문제가 발생할 수 있음.
- 코드 예제 : `std::thread`를 사용한 멀티스레드
    
    ```cpp
    #include <iostream>
    #include <thread>
    #include <vector>
    #include <mutex>
    
    std::mutex mtx; // 출력 동기화를 위한 mutex
    
    void printNumbers(int threadId) {
        for (int i = 0; i < 5; i++) {
            std::lock_guard<std::mutex> lock(mtx); // 동기화
            std::cout << "Thread ID: " << threadId << ", Number: " << i << std::endl;
        }
    }
    
    int main() {
        std::vector<std::thread> threads;
    
        // 3개의 스레드를 생성
        for (int i = 0; i < 3; i++) {
    		    // 각 스레드는 printNumbers() 함수를 실행하며, 같은 메모리를 공
            threads.emplace_back(printNumbers, i);
        }
    
        // 모든 스레드가 종료되기를 기다림
        for (auto& t : threads) {
            t.join();
        }
    
        return 0;
    }
    ```
    
    - 결과
    - ![image (3)](https://github.com/user-attachments/assets/2371681f-047f-474b-926d-0cdd180ff716)

       
        
    - `std::lock_guard<std::mutex> lock(mtx);` 덕분에 여러 쓰레드가 동시에 같은 `std::cout`에 접근하지 못하도록 막고 있다.
    - 한 쓰레드가 "Thread ID: X, Number: Y"를 출력할 때는 잠깐 뮤텍스를 얻고, 그 라인을 출력한 직후 곧바로 뮤텍스를 놓는다
    - 그 순간 다른 쓰레드가 CPU 스케줄링에 따라 바로 이어서 출력할 수도 있고, 기존 쓰레드가 계속 진행할 수도 있다
    - 이때 어떤 쓰레드가 이어서 CPU를 획득하느냐는 완전히 운영체제 스케줄러의 몫이다.

## 멀티 프로세스(Multi-Process)

- 하나의 프로그램(메인 프로세스)이 `fork()` 또는 OS API를 통해 새로운 프로세스를 생성하여 여러 프로세스가 동시에 실행되는 방식
- 각 프로세스는 독립된 메모리 공간(주소 공간)을 사용하므로, 프로세스 간 메모리 충돌이 없음

### 장점

1. **안정성**
    1. 한 프로세스가 죽어도(크래시가 나거나 에러가 발생해도) 다른 프로세스엔 영향을 주지 않음.
2. **OS 차원의 보호**
    1. 프로세스 간 메모리 보호가 자동으로 이루어져, 의도치 않은 메모리 침범이 상대적으로 적음

### 단점

1. **높은 자원 소모**
    1. 프로세스를 새로 만드는 데 많은 자원이 필요(메모리, context switch overhead 등).
2. 복잡한 통신
    1. 각 프로세스가 메모리를 공유하지 않기 때문에, 소켓, 파이프, 공유 메모리, 메시지 큐 등 IPC(Inter-Process Communication) 기법을 따로 사용해야 함

### 예시 코드

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        // 프로세스 생성 실패
        return 1;
    }
    else if (pid == 0) {
        // 자식 프로세스
        printf("자식 프로세스: PID=%d\n", getpid());
        // 자식 프로세스만의 로직 수행
    }
    else {
        // 부모 프로세스
        printf("부모 프로세스: PID=%d\n", getpid());
        wait(NULL); 
    }
    return 0;
}

```

- 부모 프로세스와 자식 프로세스가 동시에(혹은 순서대로) 실행된다.
- 각 프로세스는 **독립된** 메모리 영역을 갖게 되고, 변수나 자원도 기본적으로 공유되지 않는다.

## 멀티 스레드(Multi-Thread)

- 하나의 프로세스 안에서 여러 스레드를 생성해 동작시키는 방식
- 스레드들은 동일한 메모리 공간(데이터 영역, 힙 등)을 공유함

### 장점

1. 자원 공유
    1. 메모리를 비롯한 대부분 자원을 공유하기에, 쓰레드 간 통신 비용이 적고 자료 공유가 편함.
2. **가벼운 생성/소멸**
    1. 프로세스에 비해 스레드는 생성·소멸 비용이 작고, 문맥 교환(Context Switch)도 상대적으로 빠름.

### 단점

1. **안정성 문제**
    1. 한 스레드에서 에러가 나면 프로세스 전체에 영향을 끼칠 수 있음.
2. **동기화 필요**
    1. 동시에 공유 메모리에 접근하므로, 동기화를 위한 mutex나 semaphore 같은 도구를 많이 써야 함. 
    2. 제대로 관리 못하면 데드락이나 경쟁 조건(Race Condition)이 생길 수 있음.

## 멀티 프로세스 vs 멀티 스레드

| 구분 | 멀티 프로세스 | 멀티 스레드 |
| --- | --- | --- |
| **메모리 구조** | 서로 분리된 메모리 공간 사용 | 하나의 프로세스 내 메모리 공간 공유 |
| **생성 및 종료 비용** | 프로세스 생성/종료 비용이 큼 | 스레드 생성/종료 비용이 비교적 작음 |
| **안정성** | 한 프로세스가 죽어도 다른 프로세스에 영향 없음 | 한 스레드의 문제가 전체 프로세스에 영향 |
| **통신(데이터 공유)** | IPC(파이프, 소켓, 공유 메모리 등)를 사용해 구현해야 함 | 메모리를 공유하므로 빠른 통신 가능. 단, 동기화 문제 주의 |
| **사용 예** | 독립된 모듈 간의 안전한 실행, 마이크로서비스 분리 등 | 하나의 프로세스 내에서 병렬 계산, 빠른 스레드 간 협업 |

## 어떤 경우에 어떤 방식을 선택할까?

1. **멀티 프로세스가 유리한 경우**
    1. 서로 독립적인 모듈을 완전히 분리해서 안전하게 돌려야 하는 경우
    2. 하나가 다운돼도 다른 모듈에 영향이 없도록 하길 원할 때
    3. 운영체제의 보호 기법(메모리 보호 등)을 최대한 활용하고 싶을 때
2. **멀티 스레드가 유리한 경우**
    1. 공유 데이터가 많아, 쓰레드 간 빠른 통신과 협업이 필요한 경우
    2. 연산량이 많아 여러 코어를 효율적으로 활용해야 할 때 (예: 이미지 처리, 물리 연산, 머신러닝)
    3. 같은 주소 공간을 공유하면서 병렬 처리하면 성능이 뛰어날 때
