# 데드락 (DeadLock, 교착 상태)

> 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태

무한히 다음 자원을 기다리게 되는 상태를 말한다.

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
> 

## 용어 정리

- Race Condition : 2개 이상의 프로세스 or 스레드들이 하나의 공유 자원에 동시에 접근하려 경쟁하는 상태
- Critical Section(임계구역) : 공유 데이터에 접근하려는 코드를 의미한다.
- 뮤텍스 : 하나의 스레드만이 공유자원에 접근할 수 있도록하여 경쟁상황을 방지하는 기법
- 세마포어 : 임계 구역에 여러 스레드가 들어갈 수 있고, counter를 두어 허용 가능한 스레드를 제한해 경쟁상황을 방지하는 기법
- busy waiting(바쁜 대기): 프로세스나 스레드가 특정 조건이 만족될때까지 `계속해서 CPU를 사용`하며 대기하는 방법을 의미합니다 → CPU 낭비
    - block & wake up 방식으로 해결
        - 자원 획득을 희망하지만 자원을 획득할 수 없는 프로세스는 block시킨다.
            
            → block된 프로세스의 PCB를 semaphore의 wait-queue에 넣는다.
            
        - 다른 프로세스가 자원을 반납하면 block된 프로세스들 중 하나가 wake up 된다.
            
            → wake up된 프로세스의 PCB를 ready-queue로 옮긴다.
            
- Monitor: 동시성 프로그래밍에서 자원 접근을 제어하기 위한 고수준의 동기화 도구이다.
    - 모니터는 공유 자원에 대한 접근을 제어하는 코드 블록(임계 구역)을 포함하며, 이 코드 블록에 대해 한번에 하나의 프로세스나 스레드만 접근할 수 있도록 보장한다.

## 주로 발생하는 경우

- 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
- 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감
- 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 **`교착 상태`** 발생

## DeadLock 발생 조건

1. 상호 배제(Mutual Exclusion)
    1. 자원은 한번에 한 프로세스만 사용할 수 있음
    2. 예시
        1. 프로세스 A가 프린터를 사용 중이라면, 프로세스 B는 프린터를 사용할 수 없음
2. 점유 대기(Hold and wait)
    1. 최소한 하나의 프로세스는 **이미 자원을 점유**한 상태에서, **다른 자원 할당을 기다리는 상태**여야 함.
        1. 즉, 자원을 일부 확보한 상태로 다른 자원을 기다리는 프로세스가 존재.
    2. 예시
        1. 프로세스 A는 프린터를 점유 중이고, 스캐너가 필요해서 대기
        2. 프로세스 B는 스캐너를 점유 중이고, 프린터가 필요해서 대기
        3. 이로 인해 두 프로세스 모두 진행하지 못하고 대기 상태에 빠짐 → 서로 점유하고 있는 상태에서 상대가 끝나기를 대기하니깐
3. 비선점(No preemption)
    1. 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
    2. 예시
        1. 프로세스 A가 프린터를 점유 중이라면, 작업이 끝나기 전까지 프로세스 B가 프린터를 빼앗아 사용할 수 없음
4. 순환 대기(Circular wait)
    1. 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
    2. 각 프로세스는 다음 프로세스가 점유한 자원을 기다리며 **원형 구조**를 형성
    3. 예시
        1. 프로세스 A는 자원 R1을 점유하고 R2를 대기
        2. 프로세스 B는 자원 R2를 점유하고 R3를 대기
        3. 프로세스 C는 자원 R3을 점유하고 R1을 대기

## DeadLock 처리

### **교착 상태를 예방 & 회피**

1. 예방(prevention)
    1. 교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
        1. 상호배제 부정 : 여러 프로세스가 공유 자원 사용
            - 여러 프로세스가 접근하기 때문에 동시성 문제 발생할 수 있음
        2. 점유대기 부정 : 프로세스 실행 전 모든 자원을 할당
            - 자원이 비효율적으로 사용될 가능성 높음
        3. 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
            - 프로세스가 작업 중단과 재시작을 반복하게 될 수 있음
        4. 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
            - 요청 순서가 엄격해 설계가 복잡해질 수 있음
2. 회피(avoidance)
    1. 교착 상태 발생 시 피해나가는 방법
        1. 은행원 알고리즘(Banker's Algorithm)
            - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
            - 시스템이 안정 상태인지 확인 후 자원 할당 여부를 결정.
            - 안정 상태: 프로세스들이 자원을 모두 사용 후 해제할 수 있는 상태.
            - 안정 상태라면 자원을 할당, 그렇지 않다면 다른 프로세스의 자원 해지를 대기.
        2. 자원 할당 그래프 알고리즘(Resource-Allocation Graph Algorithm)
            - 자원과 프로세스 간의 관계를 **요청 간선**과 **할당 간선**으로 표현
            - 자원 요청 시, 요청 간선을 할당 간선으로 변경 후 **`사이클 발생 여부`**를 확인
            - **사이클이 생성된다 하여 무조건 교착상태인 것은 아니다**
                - 자원에 하나의 인스턴스만 존재 시 **교착 상태**로 판별한다
                - 자원에 여러 인스턴스가 존재 시 **교착 상태 가능성**으로 판별한다

### **교착 상태를 탐지 & 회복**

> 교착 상태가 되도록 허용한 다음 회복시키는 방법
> 

- **프로세스 종료 방법**
    - 교착 상태의 프로세스를 모두 중지
    - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
- **자원 선점 방법**
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점