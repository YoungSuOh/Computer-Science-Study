# CPU

CPU는 컴퓨터에서 가장 핵심적인 역할을 수행하는 부분.  ‘인간의 두뇌’에 해당

크게 연산 장치, 제어 장치, 레지스터 3가지로 구성됨

- 연산장치
    - 산술 연산과 논리 연산 수행
    연산에 필요한 데이터를 **레지스터**에서 가져오고, 연산 결과를 다시 **레지스터**로 저장
- 제어 장치
    - 명령어를 해독하고 실행을 제어하는 역
    - 프로그램 명령어를 읽고, 실행을 위해 연산장치(ALU), 주기억장치, 입출력 장치 등에 제어 신호를 보냄
- 레지스터
    - CPU 내부의 초고속 임시 저장 장치
    - 명령어, 연산 결과, 메모리 주소 등을 저장하는 역할
    - 범용 레지스터와 특수목적 레지스터로 나뉨
    - 특수목적 레지스터 주요 종류
        
        
        | 레지스터 | 역 |
        | --- | --- |
        | MAR (Memory Address Register) | 읽거나 쓸 메모리 주소 저장 |
        | PC (Program Counter) | 다음 실행할 명령어의 메모리  주소 저 |
        | IR (Instruction Register) | 현재 실행 중인 명령어 저장 |
        | MBR (Memory Buffer Register) | 메모리에서 읽어온 데이터 or 저장할 데이터 임시 저장 |
        | AC (Accumulator) | 연산 결과 저장 |

## CPU의 동작 과정

1. 주 기억장치는 입력장치에서 입력 받은 데이터 또는 보조 기억장치에 저장된 프로그램을 읽어옴
2.  CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장
3. 주기억장치는 연산된 데이터를 보조 기억장치(SSD/HDD) 또는 출력 장치(모니터, 프린터 등)로 보냄
4. 제어장치는 이 모든 과정이 순서대로 이루어지도록 제어

## 명령어 세트(Instruction Set)

- CPU가 이해하고 실행할 수 있는 명령어들의 집합
- 각 명령어는 **연산 코드(OPCODE) + 피연산자(Operand)**로 구성됨

### **명령어 종류**

1. **연산 명령어** → 데이터를 연산 (예: ADD, SUB, MUL)
2. **제어 명령어** → 실행 흐름 변경 (예: JUMP, CALL, RETURN)
3. **데이터 전달 명령어** → 데이터 이동 (예: LOAD, STORE)
4. **입출력 명령어** → 외부 장치와 데이터 교환 (예: IN, OUT)

## 명령어 사이클(Instruction Cycle)

CPU는 프로그램 실행을 위해 명령어를 해석하여 실행하는 과정을 반복하며, 이를 **명령어 사이클**이라 한다.

명령어 사이클은 **인출(Fetch), 해독(Decode), 실행(Execute)** 3단계로 이루어진다.

### 1) **인출(Fetch) 사이클**

CPU가 **주기억장치에서 명령어를 가져오는 과정**

1. **PC(프로그램 카운터)의 주소**를 **MAR(메모리 주소 레지스터)**로 전달 → 실행할 명령어 위치 지정
2. 해당 주소에 있는 명령어를 **MBR(메모리 버퍼 레지스터)**로 가져옴
3. PC 값을 증가시켜 다음 명령어를 가리키게 함
4. 명령어를 **IR(명령어 레지스터)**에 저장

📌 **인출 사이클 요약**

- **T0** : `MAR ← PC`
- **T1** : `MBR ← M[MAR], PC ← PC + 1`
- **T2** : `IR ← MBR`

### 2) **실행(Execute) 사이클**

명령어를 **실제로 실행하는 과정**

### **예제 1: ADD addr (덧셈 연산)**

- **T0** : `MAR ← IR(Addr)`
- **T1** : `MBR ← M[MAR]`
- **T2** : `AC ← AC + MBR`

✅ **AC(누산기)에 MBR 값(메모리 값)을 더함**

### **예제 2: LOAD addr (데이터 로드)**

- **T0** : `MAR ← IR(Addr)`
- **T1** : `MBR ← M[MAR]`
- **T2** : `AC ← MBR`

✅ **메모리에서 AC로 데이터를 가져옴**

### **예제 3: STA addr (데이터 저장)**

- **T0** : `MAR ← IR(Addr)`
- **T1** : `MBR ← AC`
- **T2** : `M[MAR] ← MBR`

✅ **AC에 있는 데이터를 메모리에 저장**

### **예제 4: JUMP addr (분기 명령어)**

- **T0** : `PC ← IR(Addr)`

✅ **PC 값을 바꿔 새로운 명령어 주소로 이동**

## **CPU 성능을 결정하는 요소**

1. **클럭 속도 (Clock Speed)**
    - CPU가 1초 동안 실행할 수 있는 명령어 사이클 수
    - 단위: **GHz(기가헤르츠)** (예: 3.5GHz → 초당 35억 개의 사이클 실행 가능)
2. **코어 개수 (Core Count)**
    - CPU 내부에 독립적으로 명령어를 실행하는 장치 개수
    - **싱글코어, 듀얼코어, 쿼드코어, 헥사코어, 옥타코어** 등
3. **캐시 메모리 (Cache Memory)**
    - CPU가 자주 사용하는 데이터를 임시 저장하는 초고속 메모리
    - **L1, L2, L3 캐시**로 구분됨 (L1이 가장 빠르지만 용량이 작음)
4. **명령어 집합(Instruction Set) 및 아키텍처**
    - **CISC (Complex Instruction Set Computing)** → 복잡한 명령어 사용 (x86 계열)
    - **RISC (Reduced Instruction Set Computing)** → 간단한 명령어 사용 (ARM 계열)

## 어셈블리어는 CPU에 직접 접근하는 언어인건가?

맞아! 어셈블리어(Assembly Language)는 **CPU와 가장 가까운 수준의 프로그래밍 언어**야. 

결국 CPU는 **기계어(0과 1로 이루어진 명령어)**만 이해할 수 있는데, 어셈블리어는 기계어를 사람이 이해할 수 있도록 변환한 거라고 보면 돼.