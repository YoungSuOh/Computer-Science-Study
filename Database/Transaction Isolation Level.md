# Transaction Isolation Level

## 트랜잭션 격리 수준 (Transaction Isolation Level)이란?

- 여러 트랜잭션이 동시에 DB에 접근할 때, 서로 간의 작업에 대해 어느 정도 “격리”를 해줄지 결정하는 설정이다.
- 격리 수준이 낮으면 동시성(성능)은 높지만 데이터 일관성을 보장하기가 까다롭고, 격리 수준이 높으면 일관성은 강화되지만 동시성이 저하될 수 있다.

대표적으로 4가지의 수준이 있다.

### 1. Read Uncommitted(level 0)

- 특징
    - 다른 트랜잭션이 **커밋하지 않은** 수정 내용까지 읽을 수 있다.
    - **Dirty Read** 문제가 발생할 수 있다.
        - 남이 아직 커밋하지 않은 데이터를 읽었다가, 상대 트랜잭션이 롤백하면 내 트랜잭션에서 읽은 값이 무의미해지는 상황
- 장단점
    - 동시성이 가장 높지만, 데이터 일관성 문제가 가장 심각
    - 실제로 이 격리 수준을 기본으로 사용하는 DBMS는 거의 없다.

### 2. Read Commited(level 1)

- 특징
    - **커밋된** 데이터만 읽을 수 있다.
    - 한 트랜잭션이 SELECT를 여러 번 실행할 때, **새로운 커밋 내용**을 계속 볼 수 있다.(Non-repeatable read 가능).
        - 예시 : 처음 SELECT와 두 번째 SELECT 사이에 다른 트랜잭션이 커밋하여 데이터를 변경했다면, 두 번째 SELECT에선 변경된 결과가 보일 수 있다.
- 장단점
    - Dirty Read는 방지하지만, Non-repeatable read 문제는 여전히 존재
    - 대부분의 Oracle, PostgreSQL 등이 기본 격리 수준으로 사용

### 3. Repeatable Read(level 2)

- 특징
    - 한 트랜잭션이 시작된 시점(또는 첫 SELECT 시점)에 읽은 스냅샷을 기준으로, **같은 SELECT를 반복 실행해도 같은 결과**를 보장
    - **Non-repeatable read**가 해결되는 대신, **Phantom Read**(유령 레코드 문제)는 여전히 발생할 수 있다.
        - 예시 : SELECT로는 특정 조건을 만족하는 행이 3개 있었는데, 같은 트랜잭션 도중에 다른 트랜잭션이 새로운 행을 INSERT 후 커밋했다면, “3개가 4개로 늘어나는” 현상이 보일 수도 있다.

### 4. Serializable(level 3)

- 특징
    - 가장 엄격한 격리 수준. 다중 트랜잭션이 순차적으로 실행된 것과 동일한 효과를 보장(직렬화 보장).
    - Phantom Read도 방지됨
    - 동시성 성능이 많이 떨어질 수 있음
- 사용 예시
    - 트랜잭션 일관성이 매우 중요한 경우에만 부분적으로 적용하거나, 전체 시스템 규모가 작을 때

## **낮은 단계 Isolation Level 활용할  때 문제점 정리**

### 1. Dirty Read

- 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션이 읽을 수 있도록 허용할 때 발생하는 현상
- 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게 되는 경우

### 2.  Non-Repeatable Read (또는 Repeatable Read 문제)

- 같은 트랜잭션 안에서 같은 SELECT를 두 번 이상 실행했는데, 그 사이에 다른 트랜잭션이 해당 데이터를 변경·커밋해버려서 읽는 결과가 달라지는 현상

### 3. Phantom Read

- 같은 조건으로 **범위 조회**(예: `SELECT * FROM ... WHERE some_condition`)를 여러 번 했을 때, 그 사이에 다른 트랜잭션이 **새로운 행을 INSERT**하거나 기존 행을 삭제·수정해서, **“유령(phantom) 같은 새 행이나 사라진 행”이 나타나는** 현상